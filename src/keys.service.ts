// Code generated by protoc-gen-tsrpc DO NOT EDIT.
// InputID: 0002b6ae23a7f36bdec7bf4686731d51508ba867

import {ServiceClient} from '@grpc/grpc-js/build/src/make-client'
import {ClientDuplexStream} from '@grpc/grpc-js/build/src/call'
import * as grpc from '@grpc/grpc-js'
import {EventEmitter} from 'events'
import * as keys from './keys'

export type RPCError = {
  name: string
  message: string
  code: number
  details: string
}

export class KeysService extends EventEmitter {
  service: ServiceClient
  
  constructor(service: ServiceClient) {
    super()
    this.service = service
  }

  emitError(err: RPCError) {
    switch (err.code) {
    case grpc.status.PERMISSION_DENIED:
    case grpc.status.UNAUTHENTICATED:
      this.emit('unauthenticated', err)
      break
    case grpc.status.UNAVAILABLE:
      this.emit('unavailable', err)
      break
    default:
      this.emit('error', err)
      break
    }
  }

  KeyGenerate(req: keys.KeyGenerateRequest): Promise<keys.KeyGenerateResponse> {
    return new Promise<keys.KeyGenerateResponse>((resolve, reject) => {
      this.service.KeyGenerate(req, (err: RPCError, resp: keys.KeyGenerateResponse) => {
        if (err) {
		  reject(err)
		  this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  Keys(req: keys.KeysRequest): Promise<keys.KeysResponse> {
    return new Promise<keys.KeysResponse>((resolve, reject) => {
      this.service.Keys(req, (err: RPCError, resp: keys.KeysResponse) => {
        if (err) {
		  reject(err)
		  this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  Key(req: keys.KeyRequest): Promise<keys.KeyResponse> {
    return new Promise<keys.KeyResponse>((resolve, reject) => {
      this.service.Key(req, (err: RPCError, resp: keys.KeyResponse) => {
        if (err) {
		  reject(err)
		  this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  KeyImport(req: keys.KeyImportRequest): Promise<keys.KeyImportResponse> {
    return new Promise<keys.KeyImportResponse>((resolve, reject) => {
      this.service.KeyImport(req, (err: RPCError, resp: keys.KeyImportResponse) => {
        if (err) {
		  reject(err)
		  this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  KeyExport(req: keys.KeyExportRequest): Promise<keys.KeyExportResponse> {
    return new Promise<keys.KeyExportResponse>((resolve, reject) => {
      this.service.KeyExport(req, (err: RPCError, resp: keys.KeyExportResponse) => {
        if (err) {
		  reject(err)
		  this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  KeyRemove(req: keys.KeyRemoveRequest): Promise<keys.KeyRemoveResponse> {
    return new Promise<keys.KeyRemoveResponse>((resolve, reject) => {
      this.service.KeyRemove(req, (err: RPCError, resp: keys.KeyRemoveResponse) => {
        if (err) {
		  reject(err)
		  this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  Sign(req: keys.SignRequest): Promise<keys.SignResponse> {
    return new Promise<keys.SignResponse>((resolve, reject) => {
      this.service.Sign(req, (err: RPCError, resp: keys.SignResponse) => {
        if (err) {
		  reject(err)
		  this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  SignFile(): ClientDuplexStream<keys.SignFileInput, keys.SignFileOutput> {
    return this.service.SignFile()
  }

  SignStream(): ClientDuplexStream<keys.SignInput, keys.SignOutput> {
    return this.service.SignStream()
  }

  Verify(req: keys.VerifyRequest): Promise<keys.VerifyResponse> {
    return new Promise<keys.VerifyResponse>((resolve, reject) => {
      this.service.Verify(req, (err: RPCError, resp: keys.VerifyResponse) => {
        if (err) {
		  reject(err)
		  this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  VerifyFile(): ClientDuplexStream<keys.VerifyFileInput, keys.VerifyFileOutput> {
    return this.service.VerifyFile()
  }

  VerifyStream(): ClientDuplexStream<keys.VerifyInput, keys.VerifyOutput> {
    return this.service.VerifyStream()
  }

  VerifyDetached(req: keys.VerifyDetachedRequest): Promise<keys.VerifyDetachedResponse> {
    return new Promise<keys.VerifyDetachedResponse>((resolve, reject) => {
      this.service.VerifyDetached(req, (err: RPCError, resp: keys.VerifyDetachedResponse) => {
        if (err) {
		  reject(err)
		  this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  VerifyDetachedFile(req: keys.VerifyDetachedFileInput): Promise<keys.VerifyDetachedResponse> {
    return new Promise<keys.VerifyDetachedResponse>((resolve, reject) => {
      this.service.VerifyDetachedFile(req, (err: RPCError, resp: keys.VerifyDetachedResponse) => {
        if (err) {
		  reject(err)
		  this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  VerifyDetachedStream(req: keys.VerifyDetachedInput): Promise<keys.VerifyDetachedResponse> {
    return new Promise<keys.VerifyDetachedResponse>((resolve, reject) => {
      this.service.VerifyDetachedStream(req, (err: RPCError, resp: keys.VerifyDetachedResponse) => {
        if (err) {
		  reject(err)
		  this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  Encrypt(req: keys.EncryptRequest): Promise<keys.EncryptResponse> {
    return new Promise<keys.EncryptResponse>((resolve, reject) => {
      this.service.Encrypt(req, (err: RPCError, resp: keys.EncryptResponse) => {
        if (err) {
		  reject(err)
		  this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  EncryptStream(): ClientDuplexStream<keys.EncryptInput, keys.EncryptOutput> {
    return this.service.EncryptStream()
  }

  EncryptFile(): ClientDuplexStream<keys.EncryptFileInput, keys.EncryptFileOutput> {
    return this.service.EncryptFile()
  }

  Decrypt(req: keys.DecryptRequest): Promise<keys.DecryptResponse> {
    return new Promise<keys.DecryptResponse>((resolve, reject) => {
      this.service.Decrypt(req, (err: RPCError, resp: keys.DecryptResponse) => {
        if (err) {
		  reject(err)
		  this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  DecryptStream(): ClientDuplexStream<keys.DecryptInput, keys.DecryptOutput> {
    return this.service.DecryptStream()
  }

  DecryptFile(): ClientDuplexStream<keys.DecryptFileInput, keys.DecryptFileOutput> {
    return this.service.DecryptFile()
  }

  Sigchain(req: keys.SigchainRequest): Promise<keys.SigchainResponse> {
    return new Promise<keys.SigchainResponse>((resolve, reject) => {
      this.service.Sigchain(req, (err: RPCError, resp: keys.SigchainResponse) => {
        if (err) {
		  reject(err)
		  this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  Statement(req: keys.StatementRequest): Promise<keys.StatementResponse> {
    return new Promise<keys.StatementResponse>((resolve, reject) => {
      this.service.Statement(req, (err: RPCError, resp: keys.StatementResponse) => {
        if (err) {
		  reject(err)
		  this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  StatementCreate(req: keys.StatementCreateRequest): Promise<keys.StatementCreateResponse> {
    return new Promise<keys.StatementCreateResponse>((resolve, reject) => {
      this.service.StatementCreate(req, (err: RPCError, resp: keys.StatementCreateResponse) => {
        if (err) {
		  reject(err)
		  this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  StatementRevoke(req: keys.StatementRevokeRequest): Promise<keys.StatementRevokeResponse> {
    return new Promise<keys.StatementRevokeResponse>((resolve, reject) => {
      this.service.StatementRevoke(req, (err: RPCError, resp: keys.StatementRevokeResponse) => {
        if (err) {
		  reject(err)
		  this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  User(req: keys.UserRequest): Promise<keys.UserResponse> {
    return new Promise<keys.UserResponse>((resolve, reject) => {
      this.service.User(req, (err: RPCError, resp: keys.UserResponse) => {
        if (err) {
		  reject(err)
		  this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  UserSearch(req: keys.UserSearchRequest): Promise<keys.UserSearchResponse> {
    return new Promise<keys.UserSearchResponse>((resolve, reject) => {
      this.service.UserSearch(req, (err: RPCError, resp: keys.UserSearchResponse) => {
        if (err) {
		  reject(err)
		  this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  UserService(req: keys.UserServiceRequest): Promise<keys.UserServiceResponse> {
    return new Promise<keys.UserServiceResponse>((resolve, reject) => {
      this.service.UserService(req, (err: RPCError, resp: keys.UserServiceResponse) => {
        if (err) {
		  reject(err)
		  this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  UserSign(req: keys.UserSignRequest): Promise<keys.UserSignResponse> {
    return new Promise<keys.UserSignResponse>((resolve, reject) => {
      this.service.UserSign(req, (err: RPCError, resp: keys.UserSignResponse) => {
        if (err) {
		  reject(err)
		  this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  UserAdd(req: keys.UserAddRequest): Promise<keys.UserAddResponse> {
    return new Promise<keys.UserAddResponse>((resolve, reject) => {
      this.service.UserAdd(req, (err: RPCError, resp: keys.UserAddResponse) => {
        if (err) {
		  reject(err)
		  this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  Search(req: keys.SearchRequest): Promise<keys.SearchResponse> {
    return new Promise<keys.SearchResponse>((resolve, reject) => {
      this.service.Search(req, (err: RPCError, resp: keys.SearchResponse) => {
        if (err) {
		  reject(err)
		  this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  Secret(req: keys.SecretRequest): Promise<keys.SecretResponse> {
    return new Promise<keys.SecretResponse>((resolve, reject) => {
      this.service.Secret(req, (err: RPCError, resp: keys.SecretResponse) => {
        if (err) {
		  reject(err)
		  this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  SecretSave(req: keys.SecretSaveRequest): Promise<keys.SecretSaveResponse> {
    return new Promise<keys.SecretSaveResponse>((resolve, reject) => {
      this.service.SecretSave(req, (err: RPCError, resp: keys.SecretSaveResponse) => {
        if (err) {
		  reject(err)
		  this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  SecretRemove(req: keys.SecretRemoveRequest): Promise<keys.SecretRemoveResponse> {
    return new Promise<keys.SecretRemoveResponse>((resolve, reject) => {
      this.service.SecretRemove(req, (err: RPCError, resp: keys.SecretRemoveResponse) => {
        if (err) {
		  reject(err)
		  this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  Secrets(req: keys.SecretsRequest): Promise<keys.SecretsResponse> {
    return new Promise<keys.SecretsResponse>((resolve, reject) => {
      this.service.Secrets(req, (err: RPCError, resp: keys.SecretsResponse) => {
        if (err) {
		  reject(err)
		  this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  Pull(req: keys.PullRequest): Promise<keys.PullResponse> {
    return new Promise<keys.PullResponse>((resolve, reject) => {
      this.service.Pull(req, (err: RPCError, resp: keys.PullResponse) => {
        if (err) {
		  reject(err)
		  this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  Push(req: keys.PushRequest): Promise<keys.PushResponse> {
    return new Promise<keys.PushResponse>((resolve, reject) => {
      this.service.Push(req, (err: RPCError, resp: keys.PushResponse) => {
        if (err) {
		  reject(err)
		  this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  Wormhole(): ClientDuplexStream<keys.WormholeInput, keys.WormholeOutput> {
    return this.service.Wormhole()
  }

  AuthSetup(req: keys.AuthSetupRequest): Promise<keys.AuthSetupResponse> {
    return new Promise<keys.AuthSetupResponse>((resolve, reject) => {
      this.service.AuthSetup(req, (err: RPCError, resp: keys.AuthSetupResponse) => {
        if (err) {
		  reject(err)
		  this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  AuthVault(req: keys.AuthVaultRequest): Promise<keys.AuthVaultResponse> {
    return new Promise<keys.AuthVaultResponse>((resolve, reject) => {
      this.service.AuthVault(req, (err: RPCError, resp: keys.AuthVaultResponse) => {
        if (err) {
		  reject(err)
		  this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  AuthUnlock(req: keys.AuthUnlockRequest): Promise<keys.AuthUnlockResponse> {
    return new Promise<keys.AuthUnlockResponse>((resolve, reject) => {
      this.service.AuthUnlock(req, (err: RPCError, resp: keys.AuthUnlockResponse) => {
        if (err) {
		  reject(err)
		  this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  AuthLock(req: keys.AuthLockRequest): Promise<keys.AuthLockResponse> {
    return new Promise<keys.AuthLockResponse>((resolve, reject) => {
      this.service.AuthLock(req, (err: RPCError, resp: keys.AuthLockResponse) => {
        if (err) {
		  reject(err)
		  this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  AuthReset(req: keys.AuthResetRequest): Promise<keys.AuthResetResponse> {
    return new Promise<keys.AuthResetResponse>((resolve, reject) => {
      this.service.AuthReset(req, (err: RPCError, resp: keys.AuthResetResponse) => {
        if (err) {
		  reject(err)
		  this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  AuthRecover(req: keys.AuthRecoverRequest): Promise<keys.AuthRecoverResponse> {
    return new Promise<keys.AuthRecoverResponse>((resolve, reject) => {
      this.service.AuthRecover(req, (err: RPCError, resp: keys.AuthRecoverResponse) => {
        if (err) {
		  reject(err)
		  this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  RuntimeStatus(req: keys.RuntimeStatusRequest): Promise<keys.RuntimeStatusResponse> {
    return new Promise<keys.RuntimeStatusResponse>((resolve, reject) => {
      this.service.RuntimeStatus(req, (err: RPCError, resp: keys.RuntimeStatusResponse) => {
        if (err) {
		  reject(err)
		  this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  Rand(req: keys.RandRequest): Promise<keys.RandResponse> {
    return new Promise<keys.RandResponse>((resolve, reject) => {
      this.service.Rand(req, (err: RPCError, resp: keys.RandResponse) => {
        if (err) {
		  reject(err)
		  this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  RandPassword(req: keys.RandPasswordRequest): Promise<keys.RandPasswordResponse> {
    return new Promise<keys.RandPasswordResponse>((resolve, reject) => {
      this.service.RandPassword(req, (err: RPCError, resp: keys.RandPasswordResponse) => {
        if (err) {
		  reject(err)
		  this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  AuthProvision(req: keys.AuthProvisionRequest): Promise<keys.AuthProvisionResponse> {
    return new Promise<keys.AuthProvisionResponse>((resolve, reject) => {
      this.service.AuthProvision(req, (err: RPCError, resp: keys.AuthProvisionResponse) => {
        if (err) {
		  reject(err)
		  this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  AuthDeprovision(req: keys.AuthDeprovisionRequest): Promise<keys.AuthDeprovisionResponse> {
    return new Promise<keys.AuthDeprovisionResponse>((resolve, reject) => {
      this.service.AuthDeprovision(req, (err: RPCError, resp: keys.AuthDeprovisionResponse) => {
        if (err) {
		  reject(err)
		  this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  AuthProvisions(req: keys.AuthProvisionsRequest): Promise<keys.AuthProvisionsResponse> {
    return new Promise<keys.AuthProvisionsResponse>((resolve, reject) => {
      this.service.AuthProvisions(req, (err: RPCError, resp: keys.AuthProvisionsResponse) => {
        if (err) {
		  reject(err)
		  this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  AuthPasswordChange(req: keys.AuthPasswordChangeRequest): Promise<keys.AuthPasswordChangeResponse> {
    return new Promise<keys.AuthPasswordChangeResponse>((resolve, reject) => {
      this.service.AuthPasswordChange(req, (err: RPCError, resp: keys.AuthPasswordChangeResponse) => {
        if (err) {
		  reject(err)
		  this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  VaultAuth(req: keys.VaultAuthRequest): Promise<keys.VaultAuthResponse> {
    return new Promise<keys.VaultAuthResponse>((resolve, reject) => {
      this.service.VaultAuth(req, (err: RPCError, resp: keys.VaultAuthResponse) => {
        if (err) {
		  reject(err)
		  this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  VaultSync(req: keys.VaultSyncRequest): Promise<keys.VaultSyncResponse> {
    return new Promise<keys.VaultSyncResponse>((resolve, reject) => {
      this.service.VaultSync(req, (err: RPCError, resp: keys.VaultSyncResponse) => {
        if (err) {
		  reject(err)
		  this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  VaultUnsync(req: keys.VaultUnsyncRequest): Promise<keys.VaultUnsyncResponse> {
    return new Promise<keys.VaultUnsyncResponse>((resolve, reject) => {
      this.service.VaultUnsync(req, (err: RPCError, resp: keys.VaultUnsyncResponse) => {
        if (err) {
		  reject(err)
		  this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  VaultStatus(req: keys.VaultStatusRequest): Promise<keys.VaultStatusResponse> {
    return new Promise<keys.VaultStatusResponse>((resolve, reject) => {
      this.service.VaultStatus(req, (err: RPCError, resp: keys.VaultStatusResponse) => {
        if (err) {
		  reject(err)
		  this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  VaultUpdate(req: keys.VaultUpdateRequest): Promise<keys.VaultUpdateResponse> {
    return new Promise<keys.VaultUpdateResponse>((resolve, reject) => {
      this.service.VaultUpdate(req, (err: RPCError, resp: keys.VaultUpdateResponse) => {
        if (err) {
		  reject(err)
		  this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  Collections(req: keys.CollectionsRequest): Promise<keys.CollectionsResponse> {
    return new Promise<keys.CollectionsResponse>((resolve, reject) => {
      this.service.Collections(req, (err: RPCError, resp: keys.CollectionsResponse) => {
        if (err) {
		  reject(err)
		  this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  Documents(req: keys.DocumentsRequest): Promise<keys.DocumentsResponse> {
    return new Promise<keys.DocumentsResponse>((resolve, reject) => {
      this.service.Documents(req, (err: RPCError, resp: keys.DocumentsResponse) => {
        if (err) {
		  reject(err)
		  this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  DocumentDelete(req: keys.DocumentDeleteRequest): Promise<keys.DocumentDeleteResponse> {
    return new Promise<keys.DocumentDeleteResponse>((resolve, reject) => {
      this.service.DocumentDelete(req, (err: RPCError, resp: keys.DocumentDeleteResponse) => {
        if (err) {
		  reject(err)
		  this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  ConfigGet(req: keys.ConfigGetRequest): Promise<keys.ConfigGetResponse> {
    return new Promise<keys.ConfigGetResponse>((resolve, reject) => {
      this.service.ConfigGet(req, (err: RPCError, resp: keys.ConfigGetResponse) => {
        if (err) {
		  reject(err)
		  this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  ConfigSet(req: keys.ConfigSetRequest): Promise<keys.ConfigSetResponse> {
    return new Promise<keys.ConfigSetResponse>((resolve, reject) => {
      this.service.ConfigSet(req, (err: RPCError, resp: keys.ConfigSetResponse) => {
        if (err) {
		  reject(err)
		  this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  AdminSignURL(req: keys.AdminSignURLRequest): Promise<keys.AdminSignURLResponse> {
    return new Promise<keys.AdminSignURLResponse>((resolve, reject) => {
      this.service.AdminSignURL(req, (err: RPCError, resp: keys.AdminSignURLResponse) => {
        if (err) {
		  reject(err)
		  this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  AdminCheck(req: keys.AdminCheckRequest): Promise<keys.AdminCheckResponse> {
    return new Promise<keys.AdminCheckResponse>((resolve, reject) => {
      this.service.AdminCheck(req, (err: RPCError, resp: keys.AdminCheckResponse) => {
        if (err) {
		  reject(err)
		  this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  MessagePrepare(req: keys.MessagePrepareRequest): Promise<keys.MessagePrepareResponse> {
    return new Promise<keys.MessagePrepareResponse>((resolve, reject) => {
      this.service.MessagePrepare(req, (err: RPCError, resp: keys.MessagePrepareResponse) => {
        if (err) {
		  reject(err)
		  this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  MessageCreate(req: keys.MessageCreateRequest): Promise<keys.MessageCreateResponse> {
    return new Promise<keys.MessageCreateResponse>((resolve, reject) => {
      this.service.MessageCreate(req, (err: RPCError, resp: keys.MessageCreateResponse) => {
        if (err) {
		  reject(err)
		  this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  Messages(req: keys.MessagesRequest): Promise<keys.MessagesResponse> {
    return new Promise<keys.MessagesResponse>((resolve, reject) => {
      this.service.Messages(req, (err: RPCError, resp: keys.MessagesResponse) => {
        if (err) {
		  reject(err)
		  this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }
}
