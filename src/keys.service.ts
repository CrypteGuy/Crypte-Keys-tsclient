// Code generated by protoc-gen-tsrpc DO NOT EDIT.
// InputID: f35e5bb6150264d68c83f1a9f2aebe6584ea6299

import {ServiceClient} from '@grpc/grpc-js/build/src/make-client'
import {ClientDuplexStream, ClientReadableStream} from '@grpc/grpc-js/build/src/call'
import * as grpc from '@grpc/grpc-js'
import {EventEmitter} from 'events'
import * as keys from './keys'
import {dummyLogger, Logger} from 'ts-log'

export type RPCError = {
  name: string
  message: string
  code: number
  details: string
}

export class KeysService extends EventEmitter {
  serviceFn: () => ServiceClient
  client?: ServiceClient
  log: Logger = dummyLogger
  
  constructor(serviceFn: () => ServiceClient) {
    super()
    this.serviceFn = serviceFn
  }

  service(): ServiceClient {
    if (!this.client) {
      this.client = this.serviceFn()
    }
    return this.client
  }

  emitError(err: RPCError) {
    switch (err.code) {
      case grpc.status.PERMISSION_DENIED:
      case grpc.status.UNAUTHENTICATED:
        this.emit('unauthenticated', err)
        break
      case grpc.status.UNAVAILABLE:
        this.emit('unavailable', err)
        break
      default:
        this.emit('error', err)
        break
	}
  }

  keyGenerate(req: keys.KeyGenerateRequest): Promise<keys.KeyGenerateResponse> {
    return new Promise<keys.KeyGenerateResponse>((resolve, reject) => {
      this.log.info('keyGenerate')
      this.service().keyGenerate(req, (err: RPCError, resp: keys.KeyGenerateResponse) => {
        if (err) {
          reject(err)
          this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  keys(req: keys.KeysRequest): Promise<keys.KeysResponse> {
    return new Promise<keys.KeysResponse>((resolve, reject) => {
      this.log.info('keys')
      this.service().keys(req, (err: RPCError, resp: keys.KeysResponse) => {
        if (err) {
          reject(err)
          this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  key(req: keys.KeyRequest): Promise<keys.KeyResponse> {
    return new Promise<keys.KeyResponse>((resolve, reject) => {
      this.log.info('key')
      this.service().key(req, (err: RPCError, resp: keys.KeyResponse) => {
        if (err) {
          reject(err)
          this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  keyImport(req: keys.KeyImportRequest): Promise<keys.KeyImportResponse> {
    return new Promise<keys.KeyImportResponse>((resolve, reject) => {
      this.log.info('keyImport')
      this.service().keyImport(req, (err: RPCError, resp: keys.KeyImportResponse) => {
        if (err) {
          reject(err)
          this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  keyExport(req: keys.KeyExportRequest): Promise<keys.KeyExportResponse> {
    return new Promise<keys.KeyExportResponse>((resolve, reject) => {
      this.log.info('keyExport')
      this.service().keyExport(req, (err: RPCError, resp: keys.KeyExportResponse) => {
        if (err) {
          reject(err)
          this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  keyRemove(req: keys.KeyRemoveRequest): Promise<keys.KeyRemoveResponse> {
    return new Promise<keys.KeyRemoveResponse>((resolve, reject) => {
      this.log.info('keyRemove')
      this.service().keyRemove(req, (err: RPCError, resp: keys.KeyRemoveResponse) => {
        if (err) {
          reject(err)
          this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  sign(req: keys.SignRequest): Promise<keys.SignResponse> {
    return new Promise<keys.SignResponse>((resolve, reject) => {
      this.log.info('sign')
      this.service().sign(req, (err: RPCError, resp: keys.SignResponse) => {
        if (err) {
          reject(err)
          this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  signFile(): ClientDuplexStream<keys.SignFileInput, keys.SignFileOutput> {
    this.log.info('signFile')
    return this.service().signFile()
  }

  signStream(): ClientDuplexStream<keys.SignInput, keys.SignOutput> {
    this.log.info('signStream')
    return this.service().signStream()
  }

  verify(req: keys.VerifyRequest): Promise<keys.VerifyResponse> {
    return new Promise<keys.VerifyResponse>((resolve, reject) => {
      this.log.info('verify')
      this.service().verify(req, (err: RPCError, resp: keys.VerifyResponse) => {
        if (err) {
          reject(err)
          this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  verifyFile(): ClientDuplexStream<keys.VerifyFileInput, keys.VerifyFileOutput> {
    this.log.info('verifyFile')
    return this.service().verifyFile()
  }

  verifyStream(): ClientDuplexStream<keys.VerifyInput, keys.VerifyOutput> {
    this.log.info('verifyStream')
    return this.service().verifyStream()
  }

  verifyDetached(req: keys.VerifyDetachedRequest): Promise<keys.VerifyDetachedResponse> {
    return new Promise<keys.VerifyDetachedResponse>((resolve, reject) => {
      this.log.info('verifyDetached')
      this.service().verifyDetached(req, (err: RPCError, resp: keys.VerifyDetachedResponse) => {
        if (err) {
          reject(err)
          this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  verifyDetachedFile(req: keys.VerifyDetachedFileInput): Promise<keys.VerifyDetachedResponse> {
    return new Promise<keys.VerifyDetachedResponse>((resolve, reject) => {
      this.log.info('verifyDetachedFile')
      this.service().verifyDetachedFile(req, (err: RPCError, resp: keys.VerifyDetachedResponse) => {
        if (err) {
          reject(err)
          this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  verifyDetachedStream(req: keys.VerifyDetachedInput): Promise<keys.VerifyDetachedResponse> {
    return new Promise<keys.VerifyDetachedResponse>((resolve, reject) => {
      this.log.info('verifyDetachedStream')
      this.service().verifyDetachedStream(req, (err: RPCError, resp: keys.VerifyDetachedResponse) => {
        if (err) {
          reject(err)
          this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  encrypt(req: keys.EncryptRequest): Promise<keys.EncryptResponse> {
    return new Promise<keys.EncryptResponse>((resolve, reject) => {
      this.log.info('encrypt')
      this.service().encrypt(req, (err: RPCError, resp: keys.EncryptResponse) => {
        if (err) {
          reject(err)
          this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  encryptStream(): ClientDuplexStream<keys.EncryptInput, keys.EncryptOutput> {
    this.log.info('encryptStream')
    return this.service().encryptStream()
  }

  encryptFile(): ClientDuplexStream<keys.EncryptFileInput, keys.EncryptFileOutput> {
    this.log.info('encryptFile')
    return this.service().encryptFile()
  }

  decrypt(req: keys.DecryptRequest): Promise<keys.DecryptResponse> {
    return new Promise<keys.DecryptResponse>((resolve, reject) => {
      this.log.info('decrypt')
      this.service().decrypt(req, (err: RPCError, resp: keys.DecryptResponse) => {
        if (err) {
          reject(err)
          this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  decryptStream(): ClientDuplexStream<keys.DecryptInput, keys.DecryptOutput> {
    this.log.info('decryptStream')
    return this.service().decryptStream()
  }

  decryptFile(): ClientDuplexStream<keys.DecryptFileInput, keys.DecryptFileOutput> {
    this.log.info('decryptFile')
    return this.service().decryptFile()
  }

  sigchain(req: keys.SigchainRequest): Promise<keys.SigchainResponse> {
    return new Promise<keys.SigchainResponse>((resolve, reject) => {
      this.log.info('sigchain')
      this.service().sigchain(req, (err: RPCError, resp: keys.SigchainResponse) => {
        if (err) {
          reject(err)
          this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  statement(req: keys.StatementRequest): Promise<keys.StatementResponse> {
    return new Promise<keys.StatementResponse>((resolve, reject) => {
      this.log.info('statement')
      this.service().statement(req, (err: RPCError, resp: keys.StatementResponse) => {
        if (err) {
          reject(err)
          this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  statementCreate(req: keys.StatementCreateRequest): Promise<keys.StatementCreateResponse> {
    return new Promise<keys.StatementCreateResponse>((resolve, reject) => {
      this.log.info('statementCreate')
      this.service().statementCreate(req, (err: RPCError, resp: keys.StatementCreateResponse) => {
        if (err) {
          reject(err)
          this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  statementRevoke(req: keys.StatementRevokeRequest): Promise<keys.StatementRevokeResponse> {
    return new Promise<keys.StatementRevokeResponse>((resolve, reject) => {
      this.log.info('statementRevoke')
      this.service().statementRevoke(req, (err: RPCError, resp: keys.StatementRevokeResponse) => {
        if (err) {
          reject(err)
          this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  user(req: keys.UserRequest): Promise<keys.UserResponse> {
    return new Promise<keys.UserResponse>((resolve, reject) => {
      this.log.info('user')
      this.service().user(req, (err: RPCError, resp: keys.UserResponse) => {
        if (err) {
          reject(err)
          this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  userSearch(req: keys.UserSearchRequest): Promise<keys.UserSearchResponse> {
    return new Promise<keys.UserSearchResponse>((resolve, reject) => {
      this.log.info('userSearch')
      this.service().userSearch(req, (err: RPCError, resp: keys.UserSearchResponse) => {
        if (err) {
          reject(err)
          this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  userService(req: keys.UserServiceRequest): Promise<keys.UserServiceResponse> {
    return new Promise<keys.UserServiceResponse>((resolve, reject) => {
      this.log.info('userService')
      this.service().userService(req, (err: RPCError, resp: keys.UserServiceResponse) => {
        if (err) {
          reject(err)
          this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  userSign(req: keys.UserSignRequest): Promise<keys.UserSignResponse> {
    return new Promise<keys.UserSignResponse>((resolve, reject) => {
      this.log.info('userSign')
      this.service().userSign(req, (err: RPCError, resp: keys.UserSignResponse) => {
        if (err) {
          reject(err)
          this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  userAdd(req: keys.UserAddRequest): Promise<keys.UserAddResponse> {
    return new Promise<keys.UserAddResponse>((resolve, reject) => {
      this.log.info('userAdd')
      this.service().userAdd(req, (err: RPCError, resp: keys.UserAddResponse) => {
        if (err) {
          reject(err)
          this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  search(req: keys.SearchRequest): Promise<keys.SearchResponse> {
    return new Promise<keys.SearchResponse>((resolve, reject) => {
      this.log.info('search')
      this.service().search(req, (err: RPCError, resp: keys.SearchResponse) => {
        if (err) {
          reject(err)
          this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  secret(req: keys.SecretRequest): Promise<keys.SecretResponse> {
    return new Promise<keys.SecretResponse>((resolve, reject) => {
      this.log.info('secret')
      this.service().secret(req, (err: RPCError, resp: keys.SecretResponse) => {
        if (err) {
          reject(err)
          this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  secretSave(req: keys.SecretSaveRequest): Promise<keys.SecretSaveResponse> {
    return new Promise<keys.SecretSaveResponse>((resolve, reject) => {
      this.log.info('secretSave')
      this.service().secretSave(req, (err: RPCError, resp: keys.SecretSaveResponse) => {
        if (err) {
          reject(err)
          this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  secretRemove(req: keys.SecretRemoveRequest): Promise<keys.SecretRemoveResponse> {
    return new Promise<keys.SecretRemoveResponse>((resolve, reject) => {
      this.log.info('secretRemove')
      this.service().secretRemove(req, (err: RPCError, resp: keys.SecretRemoveResponse) => {
        if (err) {
          reject(err)
          this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  secrets(req: keys.SecretsRequest): Promise<keys.SecretsResponse> {
    return new Promise<keys.SecretsResponse>((resolve, reject) => {
      this.log.info('secrets')
      this.service().secrets(req, (err: RPCError, resp: keys.SecretsResponse) => {
        if (err) {
          reject(err)
          this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  pull(req: keys.PullRequest): Promise<keys.PullResponse> {
    return new Promise<keys.PullResponse>((resolve, reject) => {
      this.log.info('pull')
      this.service().pull(req, (err: RPCError, resp: keys.PullResponse) => {
        if (err) {
          reject(err)
          this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  push(req: keys.PushRequest): Promise<keys.PushResponse> {
    return new Promise<keys.PushResponse>((resolve, reject) => {
      this.log.info('push')
      this.service().push(req, (err: RPCError, resp: keys.PushResponse) => {
        if (err) {
          reject(err)
          this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  wormhole(): ClientDuplexStream<keys.WormholeInput, keys.WormholeOutput> {
    this.log.info('wormhole')
    return this.service().wormhole()
  }

  authSetup(req: keys.AuthSetupRequest): Promise<keys.AuthSetupResponse> {
    return new Promise<keys.AuthSetupResponse>((resolve, reject) => {
      this.log.info('authSetup')
      this.service().authSetup(req, (err: RPCError, resp: keys.AuthSetupResponse) => {
        if (err) {
          reject(err)
          this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  authVault(req: keys.AuthVaultRequest): Promise<keys.AuthVaultResponse> {
    return new Promise<keys.AuthVaultResponse>((resolve, reject) => {
      this.log.info('authVault')
      this.service().authVault(req, (err: RPCError, resp: keys.AuthVaultResponse) => {
        if (err) {
          reject(err)
          this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  authUnlock(req: keys.AuthUnlockRequest): Promise<keys.AuthUnlockResponse> {
    return new Promise<keys.AuthUnlockResponse>((resolve, reject) => {
      this.log.info('authUnlock')
      this.service().authUnlock(req, (err: RPCError, resp: keys.AuthUnlockResponse) => {
        if (err) {
          reject(err)
          this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  authLock(req: keys.AuthLockRequest): Promise<keys.AuthLockResponse> {
    return new Promise<keys.AuthLockResponse>((resolve, reject) => {
      this.log.info('authLock')
      this.service().authLock(req, (err: RPCError, resp: keys.AuthLockResponse) => {
        if (err) {
          reject(err)
          this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  authReset(req: keys.AuthResetRequest): Promise<keys.AuthResetResponse> {
    return new Promise<keys.AuthResetResponse>((resolve, reject) => {
      this.log.info('authReset')
      this.service().authReset(req, (err: RPCError, resp: keys.AuthResetResponse) => {
        if (err) {
          reject(err)
          this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  authRecover(req: keys.AuthRecoverRequest): Promise<keys.AuthRecoverResponse> {
    return new Promise<keys.AuthRecoverResponse>((resolve, reject) => {
      this.log.info('authRecover')
      this.service().authRecover(req, (err: RPCError, resp: keys.AuthRecoverResponse) => {
        if (err) {
          reject(err)
          this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  runtimeStatus(req: keys.RuntimeStatusRequest): Promise<keys.RuntimeStatusResponse> {
    return new Promise<keys.RuntimeStatusResponse>((resolve, reject) => {
      this.log.info('runtimeStatus')
      this.service().runtimeStatus(req, (err: RPCError, resp: keys.RuntimeStatusResponse) => {
        if (err) {
          reject(err)
          this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  rand(req: keys.RandRequest): Promise<keys.RandResponse> {
    return new Promise<keys.RandResponse>((resolve, reject) => {
      this.log.info('rand')
      this.service().rand(req, (err: RPCError, resp: keys.RandResponse) => {
        if (err) {
          reject(err)
          this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  randPassword(req: keys.RandPasswordRequest): Promise<keys.RandPasswordResponse> {
    return new Promise<keys.RandPasswordResponse>((resolve, reject) => {
      this.log.info('randPassword')
      this.service().randPassword(req, (err: RPCError, resp: keys.RandPasswordResponse) => {
        if (err) {
          reject(err)
          this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  authProvision(req: keys.AuthProvisionRequest): Promise<keys.AuthProvisionResponse> {
    return new Promise<keys.AuthProvisionResponse>((resolve, reject) => {
      this.log.info('authProvision')
      this.service().authProvision(req, (err: RPCError, resp: keys.AuthProvisionResponse) => {
        if (err) {
          reject(err)
          this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  authDeprovision(req: keys.AuthDeprovisionRequest): Promise<keys.AuthDeprovisionResponse> {
    return new Promise<keys.AuthDeprovisionResponse>((resolve, reject) => {
      this.log.info('authDeprovision')
      this.service().authDeprovision(req, (err: RPCError, resp: keys.AuthDeprovisionResponse) => {
        if (err) {
          reject(err)
          this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  authProvisions(req: keys.AuthProvisionsRequest): Promise<keys.AuthProvisionsResponse> {
    return new Promise<keys.AuthProvisionsResponse>((resolve, reject) => {
      this.log.info('authProvisions')
      this.service().authProvisions(req, (err: RPCError, resp: keys.AuthProvisionsResponse) => {
        if (err) {
          reject(err)
          this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  authPasswordChange(req: keys.AuthPasswordChangeRequest): Promise<keys.AuthPasswordChangeResponse> {
    return new Promise<keys.AuthPasswordChangeResponse>((resolve, reject) => {
      this.log.info('authPasswordChange')
      this.service().authPasswordChange(req, (err: RPCError, resp: keys.AuthPasswordChangeResponse) => {
        if (err) {
          reject(err)
          this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  vaultAuth(req: keys.VaultAuthRequest): Promise<keys.VaultAuthResponse> {
    return new Promise<keys.VaultAuthResponse>((resolve, reject) => {
      this.log.info('vaultAuth')
      this.service().vaultAuth(req, (err: RPCError, resp: keys.VaultAuthResponse) => {
        if (err) {
          reject(err)
          this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  vaultSync(req: keys.VaultSyncRequest): Promise<keys.VaultSyncResponse> {
    return new Promise<keys.VaultSyncResponse>((resolve, reject) => {
      this.log.info('vaultSync')
      this.service().vaultSync(req, (err: RPCError, resp: keys.VaultSyncResponse) => {
        if (err) {
          reject(err)
          this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  vaultUnsync(req: keys.VaultUnsyncRequest): Promise<keys.VaultUnsyncResponse> {
    return new Promise<keys.VaultUnsyncResponse>((resolve, reject) => {
      this.log.info('vaultUnsync')
      this.service().vaultUnsync(req, (err: RPCError, resp: keys.VaultUnsyncResponse) => {
        if (err) {
          reject(err)
          this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  vaultStatus(req: keys.VaultStatusRequest): Promise<keys.VaultStatusResponse> {
    return new Promise<keys.VaultStatusResponse>((resolve, reject) => {
      this.log.info('vaultStatus')
      this.service().vaultStatus(req, (err: RPCError, resp: keys.VaultStatusResponse) => {
        if (err) {
          reject(err)
          this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  vaultUpdate(req: keys.VaultUpdateRequest): Promise<keys.VaultUpdateResponse> {
    return new Promise<keys.VaultUpdateResponse>((resolve, reject) => {
      this.log.info('vaultUpdate')
      this.service().vaultUpdate(req, (err: RPCError, resp: keys.VaultUpdateResponse) => {
        if (err) {
          reject(err)
          this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  collections(req: keys.CollectionsRequest): Promise<keys.CollectionsResponse> {
    return new Promise<keys.CollectionsResponse>((resolve, reject) => {
      this.log.info('collections')
      this.service().collections(req, (err: RPCError, resp: keys.CollectionsResponse) => {
        if (err) {
          reject(err)
          this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  documents(req: keys.DocumentsRequest): Promise<keys.DocumentsResponse> {
    return new Promise<keys.DocumentsResponse>((resolve, reject) => {
      this.log.info('documents')
      this.service().documents(req, (err: RPCError, resp: keys.DocumentsResponse) => {
        if (err) {
          reject(err)
          this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  documentDelete(req: keys.DocumentDeleteRequest): Promise<keys.DocumentDeleteResponse> {
    return new Promise<keys.DocumentDeleteResponse>((resolve, reject) => {
      this.log.info('documentDelete')
      this.service().documentDelete(req, (err: RPCError, resp: keys.DocumentDeleteResponse) => {
        if (err) {
          reject(err)
          this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  configGet(req: keys.ConfigGetRequest): Promise<keys.ConfigGetResponse> {
    return new Promise<keys.ConfigGetResponse>((resolve, reject) => {
      this.log.info('configGet')
      this.service().configGet(req, (err: RPCError, resp: keys.ConfigGetResponse) => {
        if (err) {
          reject(err)
          this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  configSet(req: keys.ConfigSetRequest): Promise<keys.ConfigSetResponse> {
    return new Promise<keys.ConfigSetResponse>((resolve, reject) => {
      this.log.info('configSet')
      this.service().configSet(req, (err: RPCError, resp: keys.ConfigSetResponse) => {
        if (err) {
          reject(err)
          this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  adminSignURL(req: keys.AdminSignURLRequest): Promise<keys.AdminSignURLResponse> {
    return new Promise<keys.AdminSignURLResponse>((resolve, reject) => {
      this.log.info('adminSignURL')
      this.service().adminSignURL(req, (err: RPCError, resp: keys.AdminSignURLResponse) => {
        if (err) {
          reject(err)
          this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  adminCheck(req: keys.AdminCheckRequest): Promise<keys.AdminCheckResponse> {
    return new Promise<keys.AdminCheckResponse>((resolve, reject) => {
      this.log.info('adminCheck')
      this.service().adminCheck(req, (err: RPCError, resp: keys.AdminCheckResponse) => {
        if (err) {
          reject(err)
          this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  channels(req: keys.ChannelsRequest): Promise<keys.ChannelsResponse> {
    return new Promise<keys.ChannelsResponse>((resolve, reject) => {
      this.log.info('channels')
      this.service().channels(req, (err: RPCError, resp: keys.ChannelsResponse) => {
        if (err) {
          reject(err)
          this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  channelCreate(req: keys.ChannelCreateRequest): Promise<keys.ChannelCreateResponse> {
    return new Promise<keys.ChannelCreateResponse>((resolve, reject) => {
      this.log.info('channelCreate')
      this.service().channelCreate(req, (err: RPCError, resp: keys.ChannelCreateResponse) => {
        if (err) {
          reject(err)
          this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  messagePrepare(req: keys.MessagePrepareRequest): Promise<keys.MessagePrepareResponse> {
    return new Promise<keys.MessagePrepareResponse>((resolve, reject) => {
      this.log.info('messagePrepare')
      this.service().messagePrepare(req, (err: RPCError, resp: keys.MessagePrepareResponse) => {
        if (err) {
          reject(err)
          this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  messageCreate(req: keys.MessageCreateRequest): Promise<keys.MessageCreateResponse> {
    return new Promise<keys.MessageCreateResponse>((resolve, reject) => {
      this.log.info('messageCreate')
      this.service().messageCreate(req, (err: RPCError, resp: keys.MessageCreateResponse) => {
        if (err) {
          reject(err)
          this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  messages(req: keys.MessagesRequest): Promise<keys.MessagesResponse> {
    return new Promise<keys.MessagesResponse>((resolve, reject) => {
      this.log.info('messages')
      this.service().messages(req, (err: RPCError, resp: keys.MessagesResponse) => {
        if (err) {
          reject(err)
          this.emitError(err)
          return
        }
        resolve(resp)
      })		
    })
  }

  relay(req: keys.RelayRequest): ClientReadableStream<keys.RelayOutput> {
    this.log.info('relay')
    return this.service().relay(req)
  }
}
